= Felhők hálózati szolgáltatásai laboratórium * BMEVITMMB11-HU


Házi feladat - Remény Olivér - IEY82F - 2024.05.12.

== Röviden:

* Repo: https://github.com/remenyo/cicd_ml_webpush_hf
* Webapp: https://cicdhf.11010011.xyz

Használt technológiák:

* Vue3 (Frontend)
* NodeJS 22 (Express backend API)
* Python 3.13 (Flask image processing API)
* OpenCV (Object Detection API)
* Docker (Compose)
* GitHub Actions
* GitHub Container Registry

image::release_mainpage.png[title="A github repo főoldala, jobb oldalt a releases ablakban az aktuális dokumentáció PDF" caption="{counter2:figure}{counter:figure}. {figure-caption} "]
image::actions1.png[title="Actions minden pushra lefut." caption="{counter2:figure}{counter:figure}. {figure-caption} "]
image::actions2.png[title="Egy futás részletei" caption="{counter2:figure}{counter:figure}. {figure-caption} "]
image::upload_image.png[title="Feltöltés" caption="{counter2:figure}{counter:figure}. {figure-caption} "]
image::processed.png[title="Megjelenítés" caption="{counter2:figure}{counter:figure}. {figure-caption} "]

== Áttekintés, specifikáció

Ez a feladat az alábbi részekból áll:

* Egy webes felület létrehozása, amely lehetővé tesz képek feltöltését leírásokkal együtt,
* Egy olyan rendszer kialakítása ami tárolja a képeket leírásaikkal együtt
* Egy olyan program integrálása a feltöltés folyamatába ami felismeri az autó alakú dolgokat a feltöltött képen, bekeretezi azokat és visszatér a felismert autó alakú objektumok számával
* Egy üzenő rendszerből, ami az összes feliratkozót értesíti az összes feltöltési eseményről, a feldolgozás eredményével együtt.
* Egy CI/CD folyamat megírásából, ami az előbb felsorolt szolgáltatásokat célszerűen lefordítja, és elindítja egy szerveren.

Ez a dokumentum meghatározza a webszolgáltatás fejlesztése során használt architektúrális komponenseket, technológiákat és folyamatokat.

toc::[]

// pagebreak
<<<

=== 1. Felhasználói felület (UI)

* **Technológia**: HTML+CSS+JS
  Megjegyzés: Várhatóan nem lesz szükség reaktivitásra, de ha fejlesztés során kiderül hogy mégis, akkor a Vue3 JS keretrendszer lesz alkalmazva.
* **Funkcionalitás**:
  ** Feltöltőoldal biztosítása a felhasználók számára a képek és a hozzájuk tartozó leírásokkal.
  ** Egy adott feltöltés megtekintése, ahol látható az eredeti és a feldolgozott kép (ahol az észlelt autók be vannkak keretezve), emellett a keretek száma és a felhasználói leírás is elolvasható.
  ** Lehetővé teszi a felhasználók számára az értesítésekre való feliratkozást egy egyszerű űrlapon keresztül. (Várhatóan nem kell megadni semmit, csak egy gomb lesz.)

=== 2. Képek és leírás tárolása (DB)

* **Technológia**: Fájlrendszer
  Megjegyzés: Több folyamat is hozzá fog férni egy fájlhoz, azonban egy fájlt csak egy folyamat fog írni valaha.
* **Funkcionalitás**: Egyszerű fájl írás és olvasás funkcionalitás a követelmény.
  ** Eredeti képek tárolása egy mappában
  ** Módosíott képek tárolása (egy másik mappában azonos névvel mint az eredeti kép.)
  ** Leírás tárolása (egy másik mappában azonos névvel mint az eredeti kép.)
  ** (Ha ezt a felsimerő modell igényli, feltöltés során a kép egységes méretre és formátumra alakítása.)

=== 3. Objektumfelismerés képeken (ML)

* **Technológia**: OpenCV objektumfelismerő modell
* **Funkcionalitás**:
  ** Képek nevének fogadása http apin keresztül
  ** Képek beolvasása fájlrendszerből
  ** Képeken autó alakú objektumok bekeretezése, opcionálisan címkézése
  ** "Keretezett" képek mentése fájlrendszerbe.

=== 4. Üzenőrendszer

* **Technológia**: Web push
* **Funkcionalitás**:
  ** Feliratkozók nyilvántartása (fájlrendszerben tárolt lista segítségével)
  ** Belső esemény (feltöltés és felismerés) hatására az összes feliratkozó értesítése új feltöltésről

=== 5. CI/CD rendszer

* **Technológia**: Github Actions + Docker (Build) + Docker compose remote deploy
* **Funckionalitás**:
  ** A feltöltött forráskódból docker imagek előállítása
  ** Imagek feltöltése a GitHub(vagy DockerHub) Container Registry-be
    *** Ennek a megoldásáról szól ez a bejegyzés: (https://docs.github.com/en/packages/managing-github-packages-using-github-actions-workflows/publishing-and-installing-a-package-with-github-actions#upgrading-a-workflow-that-accesses-a-registry-using-a-personal-access-token)
  ** Egy távoli szerveren futó docker compose példány utasítása, hogy töltse le az összes új image-t, és frissítse a futó konténereit az új verziókkal.
    *** Ennek a megoldásáról szól ez a bejegyzés: (https://www.docker.com/blog/how-to-deploy-on-remote-docker-hosts-with-docker-compose/) (nem használtam)
    *** Ez pedig Github Actions specifikus: (https://github.com/marketplace/actions/docker-compose-remote-deploy) (nem használtam)

// pagebreak
<<<

## Megvalósítás

=== 1. Frontend

A frontend egy VueJS 3 single page web application. Az SPA csak annyit jelent hogy minden path (/images is) az index.html betöltését eredményezi, ami aztán javascriptből kiolvassa a path-et, és annak függvényében módosítja a kinézetét, funkcionalitását.

* A `/`-n elérhető a feltöltés és a feliratkozás funckció,
* A `/image/{id}`-n pedig a feltöltött kép leírással és a detekció eredménye látható.

A kiszolgáló egy egyszerű NodeJS Express szerver (webpage-host backend service) ami kiszolgálja az index.html-t ha nem találja meg a fájlt amit kért a felhasználó (Single Page Application)

=== 2. Backend

A backend az alábbi részekből áll:

* proxy: a gatewayek között váltó program
* gateway: a weboldal és az alábbi szolgáltatások közötti közvetítő
* webpage-host: weboldalt kiszolgáló program
* file-store: képek mentése és letöltése
* subscription-handler: feliratkozást kezelő rendszer
* image-processor: autó alakú objektumok felismerése



Minden szolgáltatás a 3000-es porton érhető el alapértelmezetten, de a működés során minimum két port szükséges, mert nem a "backend" szolgálja ki a frontendet jelenleg.

A szolgaáltatás a 80-as porton érhető el ki.

=== 3. Docker

A Docker Compose kezeli a konténerizált alkalmazás telepítését.
A docker-compose.yaml fájl definiálja a szolgáltatásokat (konténereket) és azok konfigurációját.
Az image-ket a GHCR-ről szedi le, annak hatására hogy a Github Actions SSH-n szól a szervernek, hogy pullolja.

A blue-green telepítés stratégiát alkalmazok a zökkenőmentes frissítések és a gyors visszaállítás érdekében:

* Két Környezet: Két különálló környezet: "blue" és "green"
* Proxy: A proxy szerver kezeli a bejövő forgalmat és irányítja azt az aktuálisan aktív környezetbe.
* Healthcheck: A proxy folyamatosan figyeli mindkét környezet állapotát, és automatikusan átvált a másik környezetre, ha az aktív környezet meghibásodik.

=== 3. CI/CD rendszer

Források:

* Publishing and installing a package with GitHub Actions (https://docs.github.com/en/packages/managing-github-packages-using-github-actions-workflows/publishing-and-installing-a-package-with-github-actions#upgrading-a-workflow-that-accesses-a-registry-using-a-personal-access-token)

Az alábbi szekvenciadiagramn bemutatja hogy hogyan fut a CICD folyamat:
[mermaid, width=3500]
....
include::cicd_sequencediagram.mermaid[]
....
{counter:figure}. {figure-caption} CI/CD folyamat várható szekvenciadiája


A renderer dockerfile asciidoctort használ. Ezt a technológiát alkalmaztam a szakdolgozatomban, és az a tervem hogy így fogom megírni a diplomatervem is.

Egy yaml (documentation.yaml) kirendereli ezt a dokumentumot és release-be teszi a PDF-et, a másik (docker.yaml) pedig megépíti az imageket, feltölti őket a ghcr-re, majd frissíti a szerveren a docker-compose.yaml-t.
